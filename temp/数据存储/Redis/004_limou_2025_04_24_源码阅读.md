# 源码阅读

## 1.结构和对象

下面的内容是通过 [W3C](https://www.w3cschool.cn/hdclil/qkd72cqm.html) 阅读而来的内容，我做了一些整理和修改，并且参考的是加上 [注解的 Redis3.0 的这份源代码](https://github.com/huangzworks/redis-3.0-annotated)。这里复制了一份源码文件内容解读：

| 文件                                                         | 作用                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `adlist.c`、`adlist.h`                                       | 双端链表数据结构的实现。                                     |
| `ae.c`、`ae.h`、`ae_epoll.c`、`ae_evport.c`、`ae_kqueue.c`、`ae_select.c` | 事件处理器，以及各个具体实现。                               |
| `anet.c`、`anet.h`                                           | `Redis` 的异步网络框架，内容主要为对 `socket` 库的包装。     |
| `aof.c`                                                      | `AOF` 功能的实现。                                           |
| `asciilogo.h`                                                | 保存了 `Redis` 的 `ASCII LOGO`。                             |
| `bio.c`、`bio.h`                                             | `Redis` 的后台 `I/O` 程序，用于将 `I/O` 操作放到子线程里面执行， 减少 `I/O` 操作对主线程的阻塞。 |
| `bitops.c`                                                   | 二进制位操作命令的实现文件。                                 |
| `blocked.c`                                                  | 用于实现 `BLPOP` 命令和 `WAIT` 命令的阻塞效果。              |
| `cluster.c`、`cluster.h`                                     | `Redis` 的集群实现。                                         |
| `config.c`、`config.h`                                       | `Redis` 的配置管理实现，负责读取并分析配置文件， 然后根据这些配置修改 `Redis` 服务器的各个选项。 |
| `crc16.c`、`crc64.c`、`crc64.h`                              | 计算 `CRC` 校验和。                                          |
| `db.c`                                                       | 数据库实现。                                                 |
| `debug.c`                                                    | 调试实现。                                                   |
| `dict.c`、`dict.h`                                           | 字典数据结构的实现。                                         |
| `endianconv.c`、`endianconv.h`                               | 二进制的大端、小端转换函数。                                 |
| `fmacros.h`                                                  | 一些移植性方面的宏。                                         |
| `help.h`                                                     | `utils/generate-command-help.rb` 程序自动生成的命令帮助信息。 |
| `hyperloglog.c`                                              | `HyperLogLog` 数据结构的实现。                               |
| `intset.c`、`intset.h`                                       | 整数集合数据结构的实现，用于优化 `SET` 类型。                |
| `lzf_c.c`、`lzf_d.c`、`lzf.h`、`lzfP.h`                      | `Redis` 对字符串和 `RDB` 文件进行压缩时使用的 `LZF` 压缩算法的实现。 |
| `Makefile`、`Makefile.dep`                                   | 构建文件。                                                   |
| `memtest.c`                                                  | 内存测试。                                                   |
| `mkreleasehdr.sh`                                            | 用于生成释出信息的脚本。                                     |
| `multi.c`                                                    | `Redis` 的事务实现。                                         |
| `networking.c`                                               | `Redis` 的客户端网络操作库，用于实现命令请求接收、发送命令回复等工作，文件中的函数大多为 `write、read、close` 等函数的包装，以及各种协议的分析和构建函数。 |
| `notify.c`                                                   | `Redis` 的数据库通知实现。                                   |
| `object.c`                                                   | `Redis` 的对象系统实现。                                     |
| `pqsort.c`、`pqsort.h`                                       | 快速排序（`QuickSort`）算法的实现。                          |
| `pubsub.c`                                                   | 发布与订阅功能的实现。                                       |
| `rand.c` 、 `rand.h`                                         | 伪随机数生成器。                                             |
| `rdb.c` 、 `rdb.h`                                           | `RDB` 持久化功能的实现。                                     |
| `redisassert.h`                                              | `Redis` 自建的断言系统。                                     |
| `redis-benchmark.c`                                          | `Redis` 的性能测试程序。                                     |
| `redis.c`                                                    | 负责服务器的启动、维护和关闭等事项。                         |
| `redis-check-aof.c`、`redis-check-dump.c`                    | `RDB` 文件和 `AOF` 文件的合法性检查程序。                    |
| `redis-cli.c`                                                | `Redis` 客户端的实现。                                       |
| `redis.h`                                                    | `Redis` 的主要头文件，记录了 `Redis` 中的大部分数据结构， 包括服务器状态和客户端状态。 |
| `redis-trib.rb`                                              | `Redis` 集群的管理程序。                                     |
| `release.c`、`release.h`                                     | 记录和生成 `Redis` 的释出版本信息。                          |
| `replication.c`                                              | 复制功能的实现。                                             |
| `rio.c`、`rio.h`                                             | `Redis` 对文件 `I/O` 函数的包装， 在普通 `I/O` 函数的基础上增加了显式缓存、以及计算校验和等功能。 |
| `scripting.c`                                                | 脚本功能的实现。                                             |
| `sds.c`、`sds.h`                                             | `SDS` 数据结构的实现，`SDS` 为 `Redis` 的默认字符串表示。    |
| `sentinel.c`                                                 | `Redis Sentinel` 的实现。                                    |
| `setproctitle.c`                                             | 进程环境设置函数。                                           |
| `sha1.c`、`sha1.h`                                           | `SHA1` 校验和计算函数。                                      |
| `slowlog.c`、`slowlog.h`                                     | 慢查询功能的实现。                                           |
| `solarisfixes.h`                                             | 针对 `Solaris` 系统的补丁。                                  |
| `sort.c`                                                     | `SORT` 命令的实现。                                          |
| `syncio.c`                                                   | 同步 `I/O` 操作。                                            |
| `testhelp.h`                                                 | 测试辅助宏。                                                 |
| `t_hash.c`、`t_list.c`、`t_set.c`、`t_string.c`、`t_zset.c`  | 定义了 `Redis` 的各种数据类型，以及这些数据类型的命令。      |
| `util.c`、`util.h`                                           | 各种辅助函数。                                               |
| `valgrind.sup`                                               | `valgrind` 的 `suppression` 文件。                           |
| `version.h`                                                  | 记录了 `Redis` 的版本号。                                    |
| `ziplist.c`、`ziplist.h`                                     | `ZIPLIST` 数据结构的实现，用于优化 `LIST` 类型。             |
| `zipmap.c`、`zipmap.h`                                       | `ZIPMAP` 数据结构的实现，在 `Redis 2.6` 以前用与优化 `HASH` 类型， `Redis 2.6` 开始已经废弃。 |
| `zmalloc.c`、`zmalloc.h`                                     | 内存管理程序。                                               |

### 1.1.结构

#### 1.1.1.字符

`Redis` 没有直接使用 `C` 语言传统的字符串表示（即以 [空字符 \0 结尾的字符数组](https://en.wikipedia.org/wiki/Null-terminated_string)，以下简称 `C` 字符串）， 而是自己构建了一种名为简单动态字符串（`simple dynamic string, SDS`）的抽象类型， 并将 `SDS` 用作 `Redis` 的默认字符串表示。

在 `Redis` 里面， `C` 字符串只会作为字符串字面量（`string literal`），用在一些无须对字符串值进行修改的地方。比如打印日志：`redisLog(REDIS_WARNING,"Redis is now ready to exit, bye bye...");`。

当 `Redis` 需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，`Redis` 就会使用 `SDS` 来表示字符串值。比如在 `Redis` 的数据库里面，包含字符串值的键值对在底层都是由 `SDS` 实现的。

```bash
redis> SET msg "hello world"
OK
```

那么 `Redis` 将在数据库中创建一个新的键值对，其中：

*   键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串 `"msg"` 的 `SDS`
*   键值对的值是一个字符串对象，对象的底层实现是一个保存着字符串 `"hello world"` 的 `SDS`

```bash
redis> RPUSH fruits "apple" "banana" "cherry"
(integer) 3
```

那么 `Redis` 将在数据库中创建一个新的键值对，其中：

*   键值对的键是一个字符串对象，对象的底层实现是一个保存了字符串 `"fruits"` 的 `SDS`。
*   键值对的值是一个列表对象，列表对象包含了三个字符串对象，这三个字符串对象分别由三个 `SDS` 实现：第一个 `SDS` 保存着字符串 `"apple"`，第二个 `SDS` 保存着字符串 `"banana"`，第三个 `SDS` 保存着字符串 `"cherry"`。

除了用来保存数据库中的字符串值之外，`SDS` 还被用作缓冲区（`buffer`）：

-   `AOF` 模块中的 `AOF` 缓冲区
-   以及客户端状态中的输入缓冲区
-   ...

针对 `C` 字符串的痛点 `Redis` 提出的 `SDS` 实现如下：

```cpp
/*
 * 保存字符串对象的结构
 */
struct sdshdr {
    
    // buf 中已占用空间的长度
    int len;

    // buf 中剩余可用空间的长度
    int free;

    // 数据空间
    char buf[];
};

```

![img](./assets/2015-09-13_55f50d7faffa3.png)

虽然 `Redis` 避开直接操作 `C` 字符串，但是还是在 `SDS` 实现内部保留了 `\0` 结尾的风格，好处就是可以直接兼容 `C` 字符串库中的某些实用函数，比如我们需要某些时候在 `Redis` 中打印 `buf`，不过仅限于文本类型的数据，毕竟还有 `\0` 这种限制。

>   [!IMPORTANT]
>
>   补充：`C` 式字符串有很多缺点，和 `SDS` 相比很多地方都显得有些“设计缺陷”
>
>   -   **常数级获取串长度**：
>       -   必须每次 `strlen` 遍历一遍，效率低；
>       -   而 `SDS` 没有这个问题，可以直接获取到记录的长度，并且内存单位和长度单位都可以使用字节表示。
>   -   **杜绝缓冲区的溢出**：
>       -   没有边界检查，容易崩。尤其在使用 `strcat()` 时会假设目的字符串有足够多内存来容纳源头字符串的所有字符，这就是没有记录长度的另外一个后果；
>       -   而由于 `SDS` 有记录长度，就可以根据 `free` 是否合适，来决定是否新增加内存空间，除此以外 `SDS` 还实现了 `sdscat()` 把一个字符串拼接到目的 `SDS` 中，其内部就有做这样的检查。
>   -   **减少内存分配次数**：
>       -   因为 `C` 字符串并不记录自身的长度，所以对于一个包含了 `N` 个字符的 `C` 字符串来说，这个 `C` 字符串的底层实现总是一个 `N+1` 个字符长的数组（额外的一个字符空间用于保存空字符），而由于需要保持这种长度上的同步关联，因此每次修改字符串内就得重新分配内存、复制（否则无法达到字符串长度和数组长度相同的目的）；
>       -   而 `SDS` 中没有这个问题，可以预先分配字符内存大小，`SDS` 通过未使用空间解除了字符串长度和底层数组长度之间的关联。尽管在一般程序中，修改字符串长度的情况不太常出现，每次修改都执行一次内存重分配是可以接受的。但是 `Redis` 作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，如果每次修改字符串的长度都需要执行一次内存重分配的话，那么光是执行内存重分配的时间就会占去修改字符串所用时间的一大部分，如果这种修改频繁地发生的话，可能还会对性能造成影响。
>   -   **动态的空间预分配**：不会像某些 `C` 函数，当 `SDS` 的 `API` 对一个 `SDS` 进行修改，并且需要对 `SDS` 进行空间扩展的时候，程序不仅保证会为 `SDS` 分配修改所必须要的空间，还会为 `SDS` 分配额外的未使用空间。
>       -   如果对 `SDS` 进行修改之后，`SDS` 的长度（也即是 `len` 属性的值）将小于 `1 MB` ，那么程序分配和 `len` 属性同样大小的未使用空间， 这时 `SDS` 的 `len` 属性的值将和 `free` 属性的值相同。举个例子：如果进行修改之后，`SDS` 的 `len` 将变成 `13` 字节，那么程序也会分配 `13` 字节的未使用空间，`SDS` 的 `buf` 数组的实际长度将变成 `13 + 13 + 1 = 27` 字节（额外的一字节用于保存空字符）。如果大于这个 `1 MB` 再来翻倍，就会导致内存浪费。
>       -   如果对 `SDS` 进行修改之后，`SDS` 的长度将大于等于 `1 MB`，那么程序会分配 `1 MB` 的未使用空间（固定的 `1MB` 空间）。举个例子，如果进行修改之后，`SDS` 的 `len` 将变成 `30 MB`，那么程序会分配 `1 MB` 的未使用空间，`SDS` 的 `buf` 数组的实际长度将为 `30 MB + 1 MB + 1 byte`。一旦 `SDS` 的 `len` 超过 `1MB`，后续所有 `realloc` 都只额外给 `1MB`，确保内存使用是线性的、可预测的。通过这种预分配策略，`SDS` 将连续增长 `N` 次字符串所需的内存重分配次数从必定 `N` 次降低为最多 `N` 次。
>   -   **惰性空间释放策略**：通过惰性空间释放策略，`SDS` 避免了缩短字符串时所需的内存重分配操作， 并为将来可能有的增长操作提供了优化。与此同时，`SDS` 也提供了相应的 `API`，让我们可以在有需要时，真正地释放 `SDS` 里面的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。
>   -   **对二进制不够友好**：
>       -   `\0` 表示字符串结尾，不能存任意二进制数据。`C` 字符串中的字符必须符合某种编码（比如 `ASCII`），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾。这些限制使得 `C` 字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。
>       -   作为数据库还是需要保证多场景的适配性，为了确保 `Redis` 可以适用于各种不同的使用场景，`SDS` 的 `API` 都是 [二进制安全](https://en.wikipedia.org/wiki/Binary-safe) 的（`binary-safe`）：所有 `SDS API` 都会以处理二进制的方式来处理 `SDS` 存放在 `buf` 数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，它被读取时就是什么样。

相关的 `API` 您可以学习以下：

| 函数          | 作用                                                         | 时间复杂度                                                   |
| :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `sdsnew`      | 创建一个包含给定 `C` 字符串的 `SDS`。                        | ![O(N)](https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f50e98b76b4.png) ，`N` 为给定 `C` 字符串的长度。 |
| `sdsempty`    | 创建一个不包含任何内容的空 `SDS`。                           | ![O(1)](https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f50e99de6fb.png) |
| `sdsfree`     | 释放给定的 `SDS`。                                           | ![O(1)](https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f50e99de6fb.png) |
| `sdslen`      | 返回 `SDS` 的已使用空间字节数。                              | 这个值可以通过读取 `SDS` 的 `len` 属性来直接获得， 复杂度为 ![O(1)](https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f50e99de6fb.png) 。 |
| `sdsavail`    | 返回 `SDS` 的未使用空间字节数。                              | 这个值可以通过读取 `SDS` 的 `free` 属性来直接获得，复杂度为 ![O(1)](https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f50e99de6fb.png) 。 |
| `sdsdup`      | 创建一个给定 `SDS` 的副本（`copy`）。                        | ![O(N)](https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f50e98b76b4.png) ，`N` 为给定 `SDS` 的长度。 |
| `sdsclear`    | 清空 `SDS` 保存的字符串内容。                                | 因为惰性空间释放策略，复杂度为 ![O(1)](https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f50e99de6fb.png) 。 |
| `sdscat`      | 将给定 `C` 字符串拼接到 `SDS` 字符串的末尾。                 | ![O(N)](https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f50e98b76b4.png) ，`N` 为被拼接 `C` 字符串的长度。 |
| `sdscatsds`   | 将给定 `SDS` 字符串拼接到另一个 `SDS` 字符串的末尾。         | ![O(N)](https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f50e98b76b4.png) ，`N` 为被拼接 `SDS` 字符串的长度。 |
| `sdscpy`      | 将给定的 `C` 字符串复制到 `SDS` 里面，覆盖 `SDS` 原有的字符串。 | ![O(N)](https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f50e98b76b4.png) ，`N` 为被复制 `C` 字符串的长度。 |
| `sdsgrowzero` | 用空字符将 `SDS` 扩展至给定长度。                            | ![O(N)](https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f50e98b76b4.png) ，`N` 为扩展新增的字节数。 |
| `sdsrange`    | 保留 `SDS` 给定区间内的数据，不在区间内的数据会被覆盖或清除。 | ![O(N)](https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f50e98b76b4.png) ，`N` 为被保留数据的字节数。 |
| `sdstrim`     | 接受一个 `SDS` 和一个 `C` 字符串作为参数， 从 `SDS` 左右两端分别移除所有在 `C` 字符串中出现过的字符。 | ![O(M*N)](https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f50eae65cb0.png) ，`M` 为 `SDS` 的长度， `N` 为给定 `C` 字符串的长度。 |
| `sdscmp`      | 对比两个 `SDS` 字符串是否相同。                              | ![O(N)](./assets/2015-09-13_55f50e98b76b4.png) ，`N` 为两个 `SDS` 中较短的那个 SDS 的长度。 |

#### 1.1.2.链表

#### 1.1.3.字典

#### 1.1.4.跳表

#### 1.1.5.整数集合

#### 1.1.6.压缩列表

### 1.2.对象

## 2.单机数据库

### 2.1.数据库

### 2.2.持久化

### 2.3.事件

### 2.4.客户端

### 2.5.服务端

## 3.多机数据库

### 3.1.复制

### 3.2.哨兵

### 3.3.集群

## 4.独立的功能

### 4.1.发布订阅

### 4.2.事务功能

### 4.3.运行脚本

### 4.4.键值排序

### 4.5.二进制数组

### 4.6.慢查询日志

### 4.7.监视器

