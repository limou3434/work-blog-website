import{_ as i,c as a,b as n,o as e}from"./app-D7GzF563.js";const t={};function l(h,s){return e(),a("div",null,[...s[0]||(s[0]=[n(`<h2 id="_1-仿函数概念" tabindex="-1"><a class="header-anchor" href="#_1-仿函数概念"><span>1.仿函数概念</span></a></h2><p>仿函数（<code>Functor</code>）是指可以像函数一样被调用的对象，因此有一个很明显的特征就是会重载<code>()</code>符号，从而使对象具有了函数的行为。</p><p>使用仿函数可以将对象作为函数一样进行调用，这种调用行为类似于函数调用。可以像调用函数一样使用参数传递给仿函数，并获取返回值。</p><p>这使得对象具备了函数的功能，可以方便地实现自定义的操作或算法。</p><h2 id="_2-仿函数代码" tabindex="-1"><a class="header-anchor" href="#_2-仿函数代码"><span>2.仿函数代码</span></a></h2><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">#</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">include</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">iostream</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 定义一个仿函数</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">struct</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Adder</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    int</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> operator</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> a</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> b</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> const</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        return</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> a </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> b</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> main</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    //创建一个仿函数对象</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    Adder add</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    //使用仿函数进行调用，类似于函数调用</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> result </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> add</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">3</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 5</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//单看这一行您可能会认为这里调用了一个函数，实际上这是一个对象</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">cout </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;&lt;</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Result: </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> result </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;&lt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">endl</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，我们定义了一个名为 <code>Adder{}</code> 的仿函数结构体，重载了 <code>operator()</code> 函数。这个仿函数接受两个整数作为参数，并返回它们的和。</p><p>在 <code>main()</code> 函数中，我们创建了一个 <code>Adder</code> 对象 <code>add</code>，并使用它来执行加法操作。</p><h2 id="_3-仿函数作用" tabindex="-1"><a class="header-anchor" href="#_3-仿函数作用"><span>3.仿函数作用</span></a></h2><p>通过仿函数的使用，我们可以将对象看作是函数并进行调用，这在某些情况下可以提供更灵活和可定制的行为，好处是能更好做类型，替代<code>C</code>的函数回调行为（<code>C</code>使用函数指针来回调函数）例如：<code>c</code>的<code>qsort()</code>一般使用函数指针，但是<code>C++</code>的<code>sort()</code>更多使用仿函数。但是目前我们还没有办法更加深入体会，随着后续各种容器的使用您才可以体验到仿函数的作用。</p>`,10)])])}const k=i(t,[["render",l]]),d=JSON.parse('{"path":"/1.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/6nw36mv1/","title":"仿函数原理","lang":"zh-CN","frontmatter":{"createTime":"2025/06/21 15:33:58","permalink":"/1.编程语言/6nw36mv1/","title":"仿函数原理","description":"1.仿函数概念 仿函数（Functor）是指可以像函数一样被调用的对象，因此有一个很明显的特征就是会重载()符号，从而使对象具有了函数的行为。 使用仿函数可以将对象作为函数一样进行调用，这种调用行为类似于函数调用。可以像调用函数一样使用参数传递给仿函数，并获取返回值。 这使得对象具备了函数的功能，可以方便地实现自定义的操作或算法。 2.仿函数代码 在上...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"仿函数原理\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-01-25T16:36:00.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://limou3434.github.io/work-blog-website/work-blog-website/1.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/6nw36mv1/"}],["meta",{"property":"og:site_name","content":"缡墨"}],["meta",{"property":"og:title","content":"仿函数原理"}],["meta",{"property":"og:description","content":"1.仿函数概念 仿函数（Functor）是指可以像函数一样被调用的对象，因此有一个很明显的特征就是会重载()符号，从而使对象具有了函数的行为。 使用仿函数可以将对象作为函数一样进行调用，这种调用行为类似于函数调用。可以像调用函数一样使用参数传递给仿函数，并获取返回值。 这使得对象具备了函数的功能，可以方便地实现自定义的操作或算法。 2.仿函数代码 在上..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-25T16:36:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-25T16:36:00.000Z"}]]},"readingTime":{"minutes":1.63,"words":490},"git":{"createdTime":1769358960000,"updatedTime":1769358960000,"contributors":[{"name":"limou3434","username":"limou3434","email":"898738804@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/limou3434?v=4","url":"https://github.com/limou3434"}],"changelog":[{"hash":"403d4bb1a423fafb3f1de0fb7b0ef8203abf65fa","time":1769358960000,"email":"898738804@qq.com","author":"limou3434","message":"修改 Github 工作流的配置，以方便未来支持前后端拓展"}]},"autoDesc":true,"filePathRelative":"1.编程语言/2.Cpp/020_2023_09_15_ljp_仿函数原理.md","headers":[],"bulletin":true}');export{k as comp,d as data};
