import{_ as a,c as t,b as n,o as e}from"./app-D7GzF563.js";const i={};function p(l,s){return e(),t("div",null,[...s[0]||(s[0]=[n('<ol><li><strong>查找表</strong>：是对同一类型的需要被查找的元素的集合，可以使用线性表、树表、散列表（哈希表），本节我们只讨论线性表</li><li><strong>关键字</strong>：在一个数据集合中，可以唯一标识一个数据的值就是该数据的关键字</li><li><strong>查找</strong>：根据给定值，通过某种算法在查找表中确定一个关键字，该关键字代表的数据和给定值相等，则称为“查找成功”，这个过程就是“查找”</li><li><strong>动态查找表、静态查找表</strong>：若在查找的过程中会修改（插入和删除）查找表则称为“动态查找表”，否则称为“静态查找表”（如果学习过<code>C++</code>的<code>map</code>或者<code>set</code>的<code>[]</code>用法，就更能理解“动态”的过程）</li><li><strong>平均查找长度</strong>：这是类似时间复杂度或空间复杂度的算法和衡量标志，不过更多针对查找算法，公式为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo stretchy="false">(</mo><msub><mi>P</mi><mi>i</mi></msub><msub><mi>C</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ASL = \\sum_{i=1}^{n} (P_{i}C_{i})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.104em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是在表中查找第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>个数据的概率，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是在查找过程中，第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>个数据和已经比较过的关键字的个数，因此查找不同关键字会发送变化</li></ol><p>接下来我们提及的查找算法都是在数组这样的查找表中查找数据，关于树表和散列表我在<code>C++</code>部分提及。</p><h1 id="_2-顺序查找法" tabindex="-1"><a class="header-anchor" href="#_2-顺序查找法"><span>2.顺序查找法</span></a></h1><p>顺序查找算法比较容易，基本就是依次遍历查找表中的所有元素，直到找到和给定值相同的数据即可。</p><h2 id="_2-1-不带哨兵位" tabindex="-1"><a class="header-anchor" href="#_2-1-不带哨兵位"><span>2.1.不带哨兵位</span></a></h2><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//待补充...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="_2-2-带上哨兵位" tabindex="-1"><a class="header-anchor" href="#_2-2-带上哨兵位"><span>2.2.带上哨兵位</span></a></h2><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//待补充...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h1 id="_3-二分查找法" tabindex="-1"><a class="header-anchor" href="#_3-二分查找法"><span>3.二分查找法</span></a></h1><p>这个算法本身不难理解，但是编写代码非常容易越界...</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//待补充...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h1 id="_4-分块查找法" tabindex="-1"><a class="header-anchor" href="#_4-分块查找法"><span>4.分块查找法</span></a></h1><p>分块查找又被称为“索引顺序查找算法”，性能介于顺序算法和二分查找算法，为什么呢？实际上就是把一张表划分为多个子表，将每个子表中的最值作为子表的关键字，保证子表<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>内的所有元素都小于/大于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>内的所有元素，并且以二分法的方式存储子表的关键字。</p><p>因此每次查找某一个数据，只需要根据二分法的思路查找表的关键字，再根据表的关键字和给定值的进行顺序查找。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//待补充...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>',15)])])}const r=a(i,[["render",p]]),c=JSON.parse('{"path":"/2.%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/bboctzwq/","title":"1.查找的基本概念","lang":"zh-CN","frontmatter":{"createTime":"2025/06/21 15:33:58","permalink":"/2.数构算法/bboctzwq/","title":"1.查找的基本概念","description":"查找表：是对同一类型的需要被查找的元素的集合，可以使用线性表、树表、散列表（哈希表），本节我们只讨论线性表 关键字：在一个数据集合中，可以唯一标识一个数据的值就是该数据的关键字 查找：根据给定值，通过某种算法在查找表中确定一个关键字，该关键字代表的数据和给定值相等，则称为“查找成功”，这个过程就是“查找” 动态查找表、静态查找表：若在查找的过程中会修改...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"1.查找的基本概念\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-01-25T16:36:00.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://limou3434.github.io/work-blog-website/work-blog-website/2.%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/bboctzwq/"}],["meta",{"property":"og:site_name","content":"缡墨"}],["meta",{"property":"og:title","content":"1.查找的基本概念"}],["meta",{"property":"og:description","content":"查找表：是对同一类型的需要被查找的元素的集合，可以使用线性表、树表、散列表（哈希表），本节我们只讨论线性表 关键字：在一个数据集合中，可以唯一标识一个数据的值就是该数据的关键字 查找：根据给定值，通过某种算法在查找表中确定一个关键字，该关键字代表的数据和给定值相等，则称为“查找成功”，这个过程就是“查找” 动态查找表、静态查找表：若在查找的过程中会修改..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-25T16:36:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-25T16:36:00.000Z"}]]},"readingTime":{"minutes":2.19,"words":657},"git":{"createdTime":1769358960000,"updatedTime":1769358960000,"contributors":[{"name":"limou3434","username":"limou3434","email":"898738804@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/limou3434?v=4","url":"https://github.com/limou3434"}],"changelog":[{"hash":"403d4bb1a423fafb3f1de0fb7b0ef8203abf65fa","time":1769358960000,"email":"898738804@qq.com","author":"limou3434","message":"修改 Github 工作流的配置，以方便未来支持前后端拓展"}]},"autoDesc":true,"filePathRelative":"2.数构算法/1.数据结构/007_limou_2023_12_25_线性表查找.md","headers":[],"bulletin":true}');export{r as comp,c as data};
