{"content":"<p>实际上没什么好说的，这里只是简单总结一下连接池原理，顺便梳理下一个用户注册和登录的过程，进一步带您理解一些业务逻辑。</p>\n<p>预先设置好连接池内的正在等待的执行单元（进程/线程），每个执行单元保持和 <code v-pre>MySQL</code> 连接的状态，有任务（<code v-pre>SQL</code> 语句）到来就 <code v-pre>push</code> 进连接池中的执行流队列，我们完全可以自己手写一个连接池。</p>\n<p>另外，网上还有一些 <code v-pre>MySQL</code> 连接池的组件，例如 <code v-pre>hicar</code>。</p>\n<p>至于一个用户是怎么走注册和登录流程的呢？</p>\n<p>用户端向服务器 <strong>请求注册页面</strong>（也就是请求访问一个网站，对应服务端的服务器必须搭建 <code v-pre>htpp</code>，类似 <code v-pre>Nginx</code>），用户端填写注册信息，服务端 <code v-pre>get post</code> 获取表单，服务器使用一些 <code v-pre>Web</code> 语言读取各个参数数据，经过后端检查和处理，提交到多个数据库中进行交互。</p>\n<p>后端进程直接连接数据库有点过于直接（可能导致效率不高），因此就有了中间一层，也就是 <strong>中间件软件层</strong> 的概念。</p>\n<p>使用一些更加效率更高的语言和数据库进行交互，交互的时候进行 <strong>负载均衡</strong>，多个数据库中可以进行同步，加强持久性，也就是 <strong>数据库集群化</strong>，可以将多个数据库作为一个数据库来处理（多数据库也是一些数据库不实现事务的原因之一，插入只在一台服务器插入，但是查询可以查其他同步过的数据）。</p>\n<p>成功注册账户后，用户再次 <strong>请求登录页面</strong>，也是经过和上述类似的流程，就是处理逻辑有可能不太一样。</p>\n<p>而如果查数据库时，查询的某个较为频繁热度的数据，此时就会有类似缓存的 <strong>NoSQL 存储系统</strong>（例如 <code v-pre>redis</code>），高频数据直接在里面查就行。</p>\n<p>而关于整个结构的演进和效率，就可以去了解下 <strong>工程架构</strong> 和 <strong>容器技术</strong>（例如 <code v-pre>docker</code>）。</p>\n","env":{"base":"/","filePath":"/home/ljp/git/work/work-blog-website/work-blog-website-frontend/docs/4.业务服务/2.存储服务/013_ljp_2024_03_08_连接池原理和架构雏形.md","filePathRelative":"4.业务服务/2.存储服务/013_ljp_2024_03_08_连接池原理和架构雏形.md","frontmatter":{"createTime":"2025/06/21 15:33:57","permalink":"/4.业务服务/1pvpbgsk/"},"sfcBlocks":{"template":{"type":"template","content":"<template><p>实际上没什么好说的，这里只是简单总结一下连接池原理，顺便梳理下一个用户注册和登录的过程，进一步带您理解一些业务逻辑。</p>\n<p>预先设置好连接池内的正在等待的执行单元（进程/线程），每个执行单元保持和 <code v-pre>MySQL</code> 连接的状态，有任务（<code v-pre>SQL</code> 语句）到来就 <code v-pre>push</code> 进连接池中的执行流队列，我们完全可以自己手写一个连接池。</p>\n<p>另外，网上还有一些 <code v-pre>MySQL</code> 连接池的组件，例如 <code v-pre>hicar</code>。</p>\n<p>至于一个用户是怎么走注册和登录流程的呢？</p>\n<p>用户端向服务器 <strong>请求注册页面</strong>（也就是请求访问一个网站，对应服务端的服务器必须搭建 <code v-pre>htpp</code>，类似 <code v-pre>Nginx</code>），用户端填写注册信息，服务端 <code v-pre>get post</code> 获取表单，服务器使用一些 <code v-pre>Web</code> 语言读取各个参数数据，经过后端检查和处理，提交到多个数据库中进行交互。</p>\n<p>后端进程直接连接数据库有点过于直接（可能导致效率不高），因此就有了中间一层，也就是 <strong>中间件软件层</strong> 的概念。</p>\n<p>使用一些更加效率更高的语言和数据库进行交互，交互的时候进行 <strong>负载均衡</strong>，多个数据库中可以进行同步，加强持久性，也就是 <strong>数据库集群化</strong>，可以将多个数据库作为一个数据库来处理（多数据库也是一些数据库不实现事务的原因之一，插入只在一台服务器插入，但是查询可以查其他同步过的数据）。</p>\n<p>成功注册账户后，用户再次 <strong>请求登录页面</strong>，也是经过和上述类似的流程，就是处理逻辑有可能不太一样。</p>\n<p>而如果查数据库时，查询的某个较为频繁热度的数据，此时就会有类似缓存的 <strong>NoSQL 存储系统</strong>（例如 <code v-pre>redis</code>），高频数据直接在里面查就行。</p>\n<p>而关于整个结构的演进和效率，就可以去了解下 <strong>工程架构</strong> 和 <strong>容器技术</strong>（例如 <code v-pre>docker</code>）。</p>\n</template>","contentStripped":"<p>实际上没什么好说的，这里只是简单总结一下连接池原理，顺便梳理下一个用户注册和登录的过程，进一步带您理解一些业务逻辑。</p>\n<p>预先设置好连接池内的正在等待的执行单元（进程/线程），每个执行单元保持和 <code v-pre>MySQL</code> 连接的状态，有任务（<code v-pre>SQL</code> 语句）到来就 <code v-pre>push</code> 进连接池中的执行流队列，我们完全可以自己手写一个连接池。</p>\n<p>另外，网上还有一些 <code v-pre>MySQL</code> 连接池的组件，例如 <code v-pre>hicar</code>。</p>\n<p>至于一个用户是怎么走注册和登录流程的呢？</p>\n<p>用户端向服务器 <strong>请求注册页面</strong>（也就是请求访问一个网站，对应服务端的服务器必须搭建 <code v-pre>htpp</code>，类似 <code v-pre>Nginx</code>），用户端填写注册信息，服务端 <code v-pre>get post</code> 获取表单，服务器使用一些 <code v-pre>Web</code> 语言读取各个参数数据，经过后端检查和处理，提交到多个数据库中进行交互。</p>\n<p>后端进程直接连接数据库有点过于直接（可能导致效率不高），因此就有了中间一层，也就是 <strong>中间件软件层</strong> 的概念。</p>\n<p>使用一些更加效率更高的语言和数据库进行交互，交互的时候进行 <strong>负载均衡</strong>，多个数据库中可以进行同步，加强持久性，也就是 <strong>数据库集群化</strong>，可以将多个数据库作为一个数据库来处理（多数据库也是一些数据库不实现事务的原因之一，插入只在一台服务器插入，但是查询可以查其他同步过的数据）。</p>\n<p>成功注册账户后，用户再次 <strong>请求登录页面</strong>，也是经过和上述类似的流程，就是处理逻辑有可能不太一样。</p>\n<p>而如果查数据库时，查询的某个较为频繁热度的数据，此时就会有类似缓存的 <strong>NoSQL 存储系统</strong>（例如 <code v-pre>redis</code>），高频数据直接在里面查就行。</p>\n<p>而关于整个结构的演进和效率，就可以去了解下 <strong>工程架构</strong> 和 <strong>容器技术</strong>（例如 <code v-pre>docker</code>）。</p>\n","tagOpen":"<template>","tagClose":"</template>"},"script":null,"scriptSetup":null,"scripts":[],"styles":[],"customBlocks":[]},"content":"实际上没什么好说的，这里只是简单总结一下连接池原理，顺便梳理下一个用户注册和登录的过程，进一步带您理解一些业务逻辑。\n\n预先设置好连接池内的正在等待的执行单元（进程/线程），每个执行单元保持和 `MySQL` 连接的状态，有任务（`SQL` 语句）到来就 `push` 进连接池中的执行流队列，我们完全可以自己手写一个连接池。\n\n另外，网上还有一些 `MySQL` 连接池的组件，例如 `hicar`。\n\n至于一个用户是怎么走注册和登录流程的呢？\n\n用户端向服务器 **请求注册页面**（也就是请求访问一个网站，对应服务端的服务器必须搭建 `htpp`，类似 `Nginx`），用户端填写注册信息，服务端 `get post` 获取表单，服务器使用一些 `Web` 语言读取各个参数数据，经过后端检查和处理，提交到多个数据库中进行交互。\n\n后端进程直接连接数据库有点过于直接（可能导致效率不高），因此就有了中间一层，也就是 **中间件软件层** 的概念。\n\n使用一些更加效率更高的语言和数据库进行交互，交互的时候进行 **负载均衡**，多个数据库中可以进行同步，加强持久性，也就是 **数据库集群化**，可以将多个数据库作为一个数据库来处理（多数据库也是一些数据库不实现事务的原因之一，插入只在一台服务器插入，但是查询可以查其他同步过的数据）。\n\n成功注册账户后，用户再次 **请求登录页面**，也是经过和上述类似的流程，就是处理逻辑有可能不太一样。\n\n而如果查数据库时，查询的某个较为频繁热度的数据，此时就会有类似缓存的 **NoSQL 存储系统**（例如 `redis`），高频数据直接在里面查就行。\n\n而关于整个结构的演进和效率，就可以去了解下 **工程架构** 和 **容器技术**（例如 `docker`）。","excerpt":"","includedFiles":[],"tasklistId":0,"title":"","headers":[]}}
