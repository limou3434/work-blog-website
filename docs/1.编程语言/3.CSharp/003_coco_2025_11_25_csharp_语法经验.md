# 语法经验

> 本篇的语法经验并非基础语法介绍，而是笔者个人对部分语法的使用经验以及使用时遇到的坑，希望能够在开发上帮助他人不踩相同的坑。!!愿世上再无Error!!

> 如果您对基础语法不太了解或根本没有概念的话，可以先阅读 `基础介绍` 进行初步了解。在零基础的情况下 [菜鸟教程](https://www.runoob.com/csharp/csharp-tutorial.html) 、 [C语言中文网](https://c.biancheng.net/csharp/) 都是最好的引路人，基础不免有些枯燥，但是在看懂程序的那一刻相信都是有成就感的。

## 1.1 属性和字段

`属性` 和 `字段` 作为两个比较相似的概念，在笔者初学时一直有所混淆。!!不会有人用半天都搞不清吧？原来是我啊哈哈!!

首先，在 `属性` 和 `字段` 之前，要先知道变量是什么。`变量` 是一个特定的存储单元，它拥有着自定义的变量名称，可设置的变量值。

```c#
public string test = "test string"
```

如上便是一个变量，`public` 是变量的适用范围的声明，`string` 是变量类型，`test` 是变量名，`"test string"` 是变量值。

而这个变量也可以被称作字段，是一个 `公共字段`，那字段和属性的区别是什么呢？按照笔者的理解简单来讲，`属性` 是一个可以在调用时，进行具体数据处理的变量，`字段` 是一个只可以改变值的变量。

举个例子，下面是同一个含义的 `字段` 和 `属性` ，都代表的是一个存放电话号码的方式。

**字段：**

```c#
public string phone = "+86 123456789000"
```

**属性：**

```c#
private string? _phone;

public string? phone
{
    // 可以省略，让属性作为只写
    get
    {
        if (_phone == null)
            return null;
        return _phone + "+86";
    }
    // 可以省略，让属性作为只读
    set
    {
        _phone = value;
    }
}
```

这么一看 `属性` 要多写很多代码，但实际上在使用时，可以通过传入的字符串自动给电话号码添加前缀。而 `get` 中的处理完全可以根据需求进行编写，使用上来说，相比单一的 `字段` 赋值，`属性` 可以有更多的数据处理，可以让变量的处理更加统一。同样的 `set` 也可以自行数据处理。

一般来说 `属性` 不会单独出现，而是存在于实体类中，如下的用户实体类

```c#
public class UserInfo
{
    public string username {get; set;}
    
    private string? _phone;

    public string? phone
    {
        get
        {
            if (_phone == null)
                return null;
            return _phone + "+86";
        }
        set
        {
            _phone = value;
        }
    }

    public string nickname {get; set;}
}
```

通过 `username`、`phone`、`nickname` 描述了 `UserInfo` 的属性，在使用时可以对每个 `属性` 赋值进行使用。区别于 `字段` 的赋值，实体类中的 `属性` 可以进行单独修改更加多样化。

就笔者个人使用体验而言，对于有着固定结构的数据，`属性` 可以非常简便的实现数据结构的复用。而 `字段` 一般会用于比较单一的变量，虽然字典类型也可以处理复杂的变量，但笔者个人认为带有 `属性` 的实体类可以更好的统一管理和扩展。

## 1.2 反射

`反射` (Reflection) ，官方解释是命名空间中的 `System.Reflection` 类以及 `System.Type` 可用于获取有关加载的程序集及其中定义的类型的信息，例如类、接口和值类型（即结构和枚举）。 还可以使用 `反射` 在运行时创建类型实例，以及调用和访问它们。

笔者个人经验而言，可以简单的理解为 `反射` 可以认为是==在程序中调用外部文件以及文件内的程序==。非常典型的来说，现有dll文件，如果需要使用内部的程序、方法或函数，那便可以使用反射来调用（~~虽然还是不怎么用~~）。

是否会觉得用 `反射` 调用dll的方法有些多此一举，明明可以直接用==添加项目引用==功能直接添加dll文件，编写反射反而还变得麻烦了。其实 `反射` 的作用是为了动态调用，只需要将 `反射` 进行初步封装，就可以根据传入的参数调用指定的dll文件和方法。

**类库DLL：**

```c#
// dll内程序
namespace TestClassLibrary
{
    public class TestClass
    {
        public static void test(string input)
        {
            Console.WriteLine(input);
        }
    }
}
```

**项目调用：**

```c#
using System.Reflection;

namespace TestApp
{
    internal class Program
    {
        static void Main(string[] args)
        {
            string DllPath = @"your_dll_path";
            // 加载dll文件
            Assembly asm = Assembly.LoadFrom(DllPath);
            // 获取类名，必须使用 命名空间+类名  
            Type t = asm.GetType("TestClassLibrary.TestClass");
            // 实例化类
            object o = Activator.CreateInstance(t);
            // 获取指定方法
            MethodInfo method = t.GetMethod("test");
            // 入参参数
            object[] obj =
            {
                "Hello world!"
            };
            // 对方法进行调用
            var keyData = method.Invoke(o, obj);
        }
    }
}
```

上述是一个简易的反射调用例子，在运行 `TestApp` 项目后，就会弹出控制台打印出 `"Hello world!"`，这样就可以简易地调用其他的dll文件，稍作封装就可以实现动态调用dll库了。虽然动态调用非常便利，但由于性能问题，笔者在此不建议频繁使用拖垮整个程序的运行效率。

## 1.3 委托和事件

### 1.3.1 委托

`委托` （Delegate），是 `C#` 中比较特殊的语法，在各种地方都很常用。笼统点讲，`委托` 是一种类型安全的函数指针，它允许==将方法作为参数传递给其他方法==。如果需要详细了解可以查阅 [微软官方委托简介](https://learn.microsoft.com/zh-cn/dotnet/csharp/delegates-overview)。

`委托` 是一个统称，具体上来说分为一下四类 !!可以在自己的环境中调试运行熟悉一下!!：

- **delegate** 普通委托，可以**无返回值**也可以**指定返回值类型**

```c#
// 定义委托
public delegate int TestDelegate(int x, int y);
// 定义被调用方法
public static int Add(int x, int y)
{
    return x + y;
}

static void Main(string[] args)
{
    // 实例化委托
    TestDelegate test_delegate = new TestDelegate(Add);
    // 传入的入参调用Add方法后返回
    Console.WriteLine(test_delegate(4, 6));
}
```

- **action** 无返回的泛型委托

```c#
// 定义被调用方法
public static void OutputString(string input)
{
    input = "input: "+ input;
    Console.WriteLine(input);
}
// 将方法作为参数传递
public static void TestAction<T>(Action<T> action, T obj)
{
    action(obj);
}

static void Main(string[] args)
{
    // 设定泛型为string
    TestAction<string>(OutputString, "Hello World");
}
```

- **func** 必须有返回值的泛型委托

```c#
// 定义被调用方法
private static int Add(int a, int b)
{
    return a + b;
}
// 将方法作为参数
public static int TestFunc<T1, T2>(Func<T1, T2, int> func, T1 a, T2 b)
{
    return func(a, b);
}

static void Main(string[] args)
{
    int result = TestFunc<int, int>(Add, 4, 6);
    Console.WriteLine("result=" + result);
}
```

- **predicate** 只接受一个入参且返回bool的委托

```c#
// 定义被调用的方法
private static bool CompareXY(Point obj)
{
    if (obj.X > obj.Y)
        return true;
    else
        return false;
}

static void Main(string[] args)
{
    Point[] points = {
         new Point(1,2),
         new Point(2,1),
         new Point(1,1),
         new Point(2,2)
     };
    // 将CompareXY作为参数传入
    // Array.Find()的第二个参数为predicate
    Point first = Array.Find(points, CompareXY);
}
```

简单来说，上面四个都是将 `方法` 作为 `入参` 传入委托进行调用，不同的是对 `传入方法` 的要求。可以通过传入相同结构的不同方法，实现更加复用性的代码，举个例子，如果需要对两个数字进行运算操作，只需要定义好对应的**被调用方法**，在需要的地方进行委托调用即可动态实现运算。而独立出来的**被调用方法**就可以统一进行扩展管理。

### 1.3.2 事件

`事件`（Event），笼统来说是用于将特定的事件通知发送给订阅者。事件通常用于实现观察者模式，它允许一个对象将状态的变化通知其他对象，而不需要知道这些对象的细节。

对笔者而言，最为熟悉的 `事件` 就是在 `winform` 项目中的，`winform` 就是windows窗体程序（不清楚的可以自行查阅一下，理解成正常使用的桌面程序即可）。在 `winform` 中时常会用到==鼠标点下时触发事件==、==键盘按下时触发事件==等。除去 `winform` 项目，事件也可用于其他项目。如果需要详细了解可以查阅 [微软官方事件简介](https://learn.microsoft.com/zh-cn/dotnet/csharp/events-overview)。

此处代码引用 [菜鸟教程]() 的实例代码：

```c#
// 定义一个委托类型，用于事件处理程序
public delegate void NotifyEventHandler(object sender, EventArgs e);

// 发布者类
public class ProcessBusinessLogic
{
    // 声明事件
    public event NotifyEventHandler ProcessCompleted;

    // 触发事件的方法
    protected virtual void OnProcessCompleted(EventArgs e)
    {
        ProcessCompleted?.Invoke(this, e);
    }

    // 模拟业务逻辑过程并触发事件
    public void StartProcess()
    {
        Console.WriteLine("Process Started!");

        // 这里可以加入实际的业务逻辑

        // 业务逻辑完成，触发事件
        OnProcessCompleted(EventArgs.Empty);
    }
}

// 订阅者类
public class EventSubscriber
{
    public void Subscribe(ProcessBusinessLogic process)
    {
        // 注册实际调用的事件方法
        process.ProcessCompleted += Process_ProcessCompleted;
    }

    // 被调用方法
    private void Process_ProcessCompleted(object sender, EventArgs e)
    {
        Console.WriteLine("Process Completed!");
    }
}

internal class Program
{
    static void Main(string[] args)
    {
        ProcessBusinessLogic process = new ProcessBusinessLogic();
        EventSubscriber subscriber = new EventSubscriber();

        // 订阅事件
        subscriber.Subscribe(process);

        // 启动过程
        process.StartProcess();

        Console.ReadLine();
    }
}
```

上述示例简单实现了一个简单的发布和订阅，上述的注释已经比较完善可以先自行理解一下。`发布者类` 中的声明事件，就是通过实例化一个委托用于接受实际需要调用的方法。在 `订阅者类` 中通过给委托注册实际事件，在 `OnProcessCompleted()` 时就会自动触发。

还是用 `winform` 项目的逻辑进行解释，在属性中设置的==鼠标点下时触发事件==就像是提前定义的 `委托`，再给该 `事件` 添加方法时，就相当于是==注册了对应的调用方法==，在实际触发鼠标点下的事件时就会自动调用指定方法。

### 1.3.3 委托和事件的区别

这个问题几乎是八股文里的常客，在刚刚了解了 `委托` 和 `事件` 后，是否对这两个语法有了一定的了解。在笔者的经验里 `事件` 是 `委托` 的封装应用，通过对 `委托` 的封装提高了安全性，同时提供了==发布-订阅==的模式。使用上也能感受到，每次注册事件其实就是对委托进行方法的传入，和使用普通委托区别并不大。

## 1.4 泛型和Object

### 1.4.1 泛型

`泛型` （Generic），是各种语言中比较常见的一个语法，在 `C#` 中时常会遇到 参数类型是 `T` 的情况。而 `T` 就是一般用于代指 `泛型` 的字母（其实也可以自定义，但后续为方便，都以 `T` 作为代指），此处列出标记符仅供参考。

**泛型标记符：**

- E Element集合元素
- T Type Java类
- K Key 键v Value值
- N Number 数值类型
- ?表示不确定的Java类型

其实 A-Z都可以作为 `泛型` 标记符，上面只是一种约定，增强代码的可读性，方便团队间的合作开发。

在 [微软泛型类型概述](https://learn.microsoft.com/zh-cn/dotnet/standard/generics/) 中也对 `泛型` 有所描述， `泛型` 是具有占位符（类型参数）的==类、结构、接口和方法==，用于存储或使用的一个或多个类型。 `泛型` 集合类可能使用类型参数作为它存储的对象类型的占位符。类型参数显示为其字段的类型及其方法的参数类型。 `泛型` 方法可能将其类型参数用作其返回值的类型或其正式参数之一的类型。

笔者个人的理解比较通俗，`泛型` 可以看作是一个容器，在==实例化或定义==时，就相当于是给容器倒水、饮料等各种各样的液体。在确定了容器内的类型后，返回也将会是该类型。!!不会出现刘谦变魔术呢样的！!! 在之前 `委托` 的示例代码中，也有使用到 `泛型` ，目的也是为了让代码更为复用和便利。

```c#
待补充
```

上述代码就是一个简便的 `泛型` 例子，通过传入参数，将两个参数进行交换。而 `T` 便是传入的类型。如果能理解的话，可以看看之前 `委托` 的示例代码，代码中该代码中的 `TestAction<T>` 就在使用时被定义为 `string` 类型。

### 1.4.2 泛型和Object

说到这个题目时，您会不会好奇，既然已经有了 `object` 这个便利的万能类型，那为什么还需要有 `泛型` 的存在呢？总的来说，是因为 `安全性`。 

`object` 作为万能类型，是==所有类型的父类==，可以==强制转换==成任意类型。

```c#
object o1 = 123;
int x = (int)o1;

object o2 = "hello";
string y = (string)o2;
```

从上面的代码，可以很清晰的看到在赋值给对应 `变量` 时，需要进行==强制转换==而这个过程就是简易的 `装箱` 和 `拆箱` 。`int` 类型的123先被装箱成为 `object` 类型的o1，在赋值时 `object` 被 `拆箱` 赋值为y。这个过程并不安全，而且每次都需要手动强制转换也非常麻烦。

而相较于 `object` 的手动强制转换，`泛型` 并不需要 `装箱拆箱` 操作，在明确类型的情况下，可以让代码更加复用更加安全。所以总的来说，`泛型` 非常适合用于已确定类型时提高==代码复用性==，而 `object` 适合用于不确定类型，如反射等情况下，手动强制转换来确定变量类型的情况。