# 语法经验

> 本篇的语法经验并非基础语法介绍，而是笔者个人对部分语法的使用经验以及使用时遇到的坑，希望能够在开发上帮助他人不踩相同的坑。!!愿世上再无Error!!

> 如果您对基础语法不太了解或根本没有概念的话，可以先阅读 `基础介绍` 进行初步了解。在零基础的情况下 [菜鸟教程](https://www.runoob.com/csharp/csharp-tutorial.html) 、 [C语言中文网](https://c.biancheng.net/csharp/) 都是最好的引路人，基础不免有些枯燥，但是在看懂程序的那一刻相信都是有成就感的。

## 1. 属性和字段

`属性` 和 `字段` 作为两个比较相似的概念，在笔者初学时一直有所混淆。!!~~不会有人用半天都搞不清吧？原来是我啊哈哈~~!!

首先，在 `属性` 和 `字段` 之前，要先知道变量是什么。`变量` 是一个特定的存储单元，它拥有着自定义的变量名称，可设置的变量值。

```c#
public string test = "test string"
```

如上便是一个变量，`public` 是变量的适用范围的声明，`string` 是变量类型，`test` 是变量名，`"test string"` 是变量值。

而这个变量也可以被称作字段，是一个 `公共字段`，那字段和属性的区别是什么呢？按照笔者的理解简单来讲，`属性` 是一个可以在调用时，进行具体数据处理的变量，`字段` 是一个只可以改变值的变量。

举个例子，下面是同一个含义的 `字段` 和 `属性` ，都代表的是一个存放电话号码的方式。

**字段：**

```c#
public string phone = "+86 123456789000"
```

**属性：**

```c#
private string? _phone;

public string? phone
{
    // 可以省略，让属性作为只写
    get
    {
        if (_phone == null)
            return null;
        return _phone + "+86";
    }
    // 可以省略，让属性作为只读
    set
    {
        _phone = value;
    }
}
```

这么一看 `属性` 要多写很多代码，但实际上在使用时，可以通过传入的字符串自动给电话号码添加前缀。而 `get` 中的处理完全可以根据需求进行编写，使用上来说，相比单一的 `字段` 赋值，`属性` 可以有更多的数据处理，可以让变量的处理更加统一。同样的 `set` 也可以自行数据处理。

一般来说 `属性` 不会单独出现，而是存在于实体类中，如下的用户实体类

```c#
public class UserInfo
{
    public string username {get; set;}
    
    private string? _phone;

    public string? phone
    {
        get
        {
            if (_phone == null)
                return null;
            return _phone + "+86";
        }
        set
        {
            _phone = value;
        }
    }

    public string nickname {get; set;}
}
```

通过 `username`、`phone`、`nickname` 描述了 `UserInfo` 的属性，在使用时可以对每个 `属性` 赋值进行使用。区别于 `字段` 的赋值，实体类中的 `属性` 可以进行单独修改更加多样化。

就笔者个人使用体验而言，对于有着固定结构的数据，`属性` 可以非常简便的实现数据结构的复用。而 `字段` 一般会用于比较单一的变量，虽然字典类型也可以处理复杂的变量，但笔者个人认为带有 `属性` 的实体类可以更好的统一管理和扩展。

## 2. 反射

`反射` (Reflection) ，官方解释是命名空间中的 `System.Reflection` 类以及 `System.Type` 可用于获取有关加载的程序集及其中定义的类型的信息，例如类、接口和值类型（即结构和枚举）。 还可以使用 `反射` 在运行时创建类型实例，以及调用和访问它们。

笔者个人经验而言，可以简单的理解为 `反射` 可以认为是==在程序中调用外部文件以及文件内的程序==。非常典型的来说，现有dll文件，如果需要使用内部的程序、方法或函数，那便可以使用反射来调用（~~虽然还是不怎么用~~）。

是否会觉得用 `反射` 调用dll的方法有些多此一举，明明可以直接用==添加项目引用==功能直接添加dll文件，编写反射反而还变得麻烦了。其实 `反射` 的作用是为了动态调用，只需要将 `反射` 进行初步封装，就可以根据传入的参数调用指定的dll文件和方法。

**类库DLL：**

```c#
// dll内程序
namespace TestClassLibrary
{
    public class TestClass
    {
        public static void test(string input)
        {
            Console.WriteLine(input);
        }
    }
}
```

**项目调用：**

```c#
using System.Reflection;

namespace TestApp
{
    internal class Program
    {
        static void Main(string[] args)
        {
            string DllPath = @"your_dll_path";
            // 加载dll文件
            Assembly asm = Assembly.LoadFrom(DllPath);
            // 获取类名，必须使用 命名空间+类名  
            Type t = asm.GetType("TestClassLibrary.TestClass");
            // 实例化类
            object o = Activator.CreateInstance(t);
            // 获取指定方法
            MethodInfo method = t.GetMethod("test");
            // 入参参数
            object[] obj =
            {
                "Hello world!"
            };
            // 对方法进行调用
            var keyData = method.Invoke(o, obj);
        }
    }
}
```

上述是一个简易的反射调用例子，在运行 `TestApp` 项目后，就会弹出控制台打印出 `"Hello world!"`，这样就可以简易地调用其他的dll文件，稍作封装就可以实现动态调用dll库了。虽然动态调用非常便利，但由于性能问题，笔者在此不建议频繁使用拖垮整个程序的运行效率。

## 3. 委托和事件

待补充...